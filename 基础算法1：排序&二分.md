# 基础算法1：排序&二分

写在前面：这个学期零零散散搞了一些东西，感觉都没有坚持住，在第五周周末开始学习一些算法的板子，做一些题目，希望能够坚持并且有所成效吧。

首先要真正理解算法的思想，然后把这些板子都给背过（尤其是很恶的边界问题）。同时还要通过模板题去刷题检验，及时复习；然后平时做一些网站上的算法题进行应用。虽然我感觉这些题目真的好难啊，要是第一次做肯定做不出来。想不出来的时候就去看题解，理解别人的思路，看多了也许慢慢就会了呢。

总之一切才刚刚开始，学习急不得。

### 快速排序 quick_sort

对一段l-r的区间进行排序，使用分治的思想

step 1 确定分界点x（只是一个哨兵值，排序之后并非一定在中间，但是会确保分成两段！）  板子里面是array[l]

step 2  **划分区间**：使得左边区间所有数小于等于x，右边区间所有数大于x

step 3 递归地完成左半区域和右半区域



实现方法1：很好理解，但是需要开辟两个新的数组，会浪费额外的空间。

实现方法2：双指针对区域进行扫描。先移动i，遇到小于x的就i++，直到遇到大于x的，停下来等j

​			j也移动，直到遇到小于等于x的，就进行交换了。交换之后两个指针都移动，持续进行，直到指

​			针相遇，就成功一分为二了。

**注意！：i指针严格左侧的一定小于等于哨兵值x，j指针严格右侧的一定大于等于哨兵值x！！！两个指针可能指向同一个地方，也有可能交错，都是可以满足这个要求的**

**边界问题的模板一定要背清楚！！**



```cpp
void quick_sort(int l,int r,int q[]){//注意传入参数的时候可以是不指定数组的长度的
    if(l>=r) return; //递归退出条件，区间太小了就说明结束了
    
    int x=q[l],i=l-1,j=r+1;
    while(i<j){
        do i++; while(q[i]<x);
    	do j--; while(q[j]>x);
        if(i<j) swap(q[i],q[j]);
    }
    
    quick_sort(l,j,q);
    quick_sort(j+1,r,q);//递归地处理，统一用j为新的边界
   
}
```



### 归并排序 merge-sort

以严格中心点为分界线，使用分治思想

step 1 确定分界点：以mid中间位置作为分界点

step 2 使用递归，排left和right，使之都成为有序的序列

step 3 **归并** 将两个有序序列合二为一！使用双指针进行合并！两个指针分别指向两个子序列，比较后将较小值放		入res中，并进行移动，直到某一个子序列完毕了，则退出循环，将另外一个子序列剩下的填补到res中

```cpp
void merge_sort(int l,int r,int q[]){
    if(l>=r) return;

    int mid=(l+r)>>1;
    merge_sort(l,mid,q);
    merge_sort(mid+1,r,q);

    int i=l,j=mid+1,k=0;//注意辅助数组只是0开始的
    while(i<=mid&&j<=r){
        if(q[i]<=q[j]) tmp[k++]=q[i++];
        else tmp[k++]=q[j++];
    }
    while(i<=mid) tmp[k++]=q[i++];
    while(j<=r) tmp[k++]=q[j++];

    for(int i=l,j=0;i<=r;i++,j++){//赋值！要注意了
        q[i]=tmp[j];
    }
}

```

**注意：统计逆序对的个数，也可以用归并排序的思想来做，在归并的过程中顺手就把逆序对给计算了！**

同时，要好好体会这种先递归处理，再进行合并的思想。拿到手已经是两个排好了的序列了，很方便。



### 整数二分 binary-search

对某个性质P，将区间划分为两块，左半边不满足P，右半边满足P，（或者反过来，所以有两个有区别的板子）

**通过取区间中点mid进行判断，再不断根据判断结果更新left和right的值，同时确保目标边界在[l,r]之内，这样就可以不断逼近正确边界！  最终，整数二分一定有：**

#### l=r  ！



二分就是寻找性质P的边界！核心就是边界问题！！！

目标是寻找边界的那个整数点！ 要熟悉板子的区分与使用情况。



模板1：右半边区间满足，左半边不满足的情况

​	如何二分出来不满足的边界位置？

​	step 1 先找到l和r的中间点，check()一下是否满足

​	step 2 分类，如果满足则更新l，不满足则更新r

​	step 3 循环，直到满足l=r则说明找到了x，返回l=r=x即可

```cpp
int binarySearch1(int l,int r){
    while(l<r){//最终等于，退出循环
        int mid=l+r+1>>1;   //注意此处条件！！因为看到下面是l=mid 又因为向下取整特性，这里必须+1
        					//否则在l与r只相差1的时候，mid永远是l就会发生死循环。
        if(check(mid)) l=mid;
        else r=mid-1；
    }
    return l;//找到了，l=r，返回啥都可以~
}
```



模板2：另一种情况，左半区间满足，右半不满足

```cpp

```

**规律总结：**

1.这两个板子的边界处其实都是true的，也就是说边界符合条件，所以check(mid)是true的时候会直接把mid赋值给l或者r，而不需要进行+1或-1调整，因为如果目标恰好等于l或者r也可以。反之，check(mid)是false的时候要调

2.保证区间永远在[l,r]之内，注意l和r**都是可以取到等号的**！！最终不断逼近，就得到了l=r=x目标~~

3 L和r的小规律：当l=mid的时候，r=mid-1，同时mid的表达式也要做出相应的修改；   当r=mid的时候，l=mid+1 



### 浮点数二分

与整数二分的思想是类似的，也是通过不断取mid，更新l和r的值，确保**正确答案一定在区间[l,r]里面**

当区间足够短的时候（或者循环次数达到设定值的时候…）就可以退出循环，用l或者r的值来近似正确答案

由于不涉及边界问题，只需无脑mid=(l+r)/2 所以这个板子是很简单的。

```cpp
double doubleBinary(double l,double r){
    while(r-l>1e-6){  //这里有一个小技巧，就是题目要求的精度是四位小数，你就保留到1e-6，多2位就可以
        double mid=(l+r)/2;
        if(check(mid)) l=mid;
        else r=mid;
    }
    return l;//或者r
}
```







